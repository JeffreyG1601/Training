<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pac-Man</title>
  <style>
    body {
      background-color: #000;
      color: #fff;
      text-align: center;
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }

    canvas {
      border: 2px solid #fff;
      background: black;
    }

    h1 {
      margin: 10px;
    }

    #info {
      margin-bottom: 10px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>Pac-Man Lite</h1>
  <div id="info">Score: 0</div>
  <canvas id="game"></canvas>

  <script>
    const tileSize = 20;
    const mazeLayout = [
      "#####################",
      "#.........#........o#",
      "#.###.###.#.###.###.#",
      "#.#.....#.#.#.....#.#",
      "#.###.#.###.#.###.#.#",
      "#...................#",
      "#.###.#.#####.#.###.#",
      "#.....#...#...#.....#",
      "#####.###.#.###.#####",
      "#.........#.........#",
      "#####.###.#.###.#####",
      "#.....#...o...#.....#",
      "#.###.#.#####.#.###.#",
      "#...................#",
      "#.###.#.###.#.###.#.#",
      "#.#...#.#.#.#.#...#.#",
      "#.###.###.#.###.###.#",
      "#o........#........o#",
      "#####################"
    ];

    const rows = mazeLayout.length;
    const cols = mazeLayout[0].length;
    const canvas = document.getElementById("game");
    canvas.width = cols * tileSize;
    canvas.height = rows * tileSize;
    const ctx = canvas.getContext("2d");
    const infoDisplay = document.getElementById("info");

    let maze = mazeLayout.map(row => row.split(""));
    let score = 0;
    let poweredUp = false;
    let powerTimer = 0;
    let powerTimerStart = 0;
    let gameOver = false;

    const pacman = {
      x: 1,
      y: 1,
      dx: 0,
      dy: 0,
      nextDx: 0,
      nextDy: 0
    };

    let lastPacmanX = pacman.x;
    let lastPacmanY = pacman.y;

    const ghosts = [
      { x: Math.floor(cols / 2), y: Math.floor(rows / 2), color: "red", dx: 0, dy: 0, eaten: false, prevX: 0, prevY: 0 },
      { x: Math.floor(cols / 2) + 1, y: Math.floor(rows / 2), color: "cyan", dx: 0, dy: 0, eaten: false, prevX: 0, prevY: 0 }
    ];

    document.addEventListener("keydown", e => {
      switch (e.key) {
        case "ArrowUp": pacman.nextDx = 0; pacman.nextDy = -1; break;
        case "ArrowDown": pacman.nextDx = 0; pacman.nextDy = 1; break;
        case "ArrowLeft": pacman.nextDx = -1; pacman.nextDy = 0; break;
        case "ArrowRight": pacman.nextDx = 1; pacman.nextDy = 0; break;
      }
    });

    function drawMaze() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const tile = maze[y][x];
          if (tile === "#") {
            ctx.fillStyle = "blue";
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          } else if (tile === ".") {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 2, 0, Math.PI * 2);
            ctx.fill();
          } else if (tile === "o") {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    }

    function drawEntity(entity, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(entity.x * tileSize + tileSize / 2, entity.y * tileSize + tileSize / 2, tileSize / 2 - 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function movePacman() {
      const nextX = pacman.x + pacman.nextDx;
      const nextY = pacman.y + pacman.nextDy;
      if (maze[nextY] && maze[nextY][nextX] !== "#") {
        pacman.dx = pacman.nextDx;
        pacman.dy = pacman.nextDy;
      }

      const newX = pacman.x + pacman.dx;
      const newY = pacman.y + pacman.dy;

      if (maze[newY] && maze[newY][newX] !== "#") {
        pacman.x = newX;
        pacman.y = newY;
      }

      const tile = maze[pacman.y][pacman.x];
      if (tile === ".") {
        maze[pacman.y][pacman.x] = " ";
        score += 1;
      } else if (tile === "o") {
        maze[pacman.y][pacman.x] = " ";
        poweredUp = true;
        powerTimer = 4000;
        powerTimerStart = Date.now();
        ghosts.forEach(g => g.eaten = false);
        score += 10;
      }
    }

    function moveGhosts() {
      ghosts.forEach(g => {
        const directions = [
          { dx: 1, dy: 0 },
          { dx: -1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: 0, dy: -1 }
        ];

        const validMoves = directions
          .filter(d => {
            const tx = g.x + d.dx;
            const ty = g.y + d.dy;
            return maze[ty] && maze[ty][tx] !== "#";
          })
          .sort((a, b) => {
            const da = Math.abs((g.x + a.dx) - pacman.x) + Math.abs((g.y + a.dy) - pacman.y);
            const db = Math.abs((g.x + b.dx) - pacman.x) + Math.abs((g.y + b.dy) - pacman.y);
            return da - db;
          });

        const move = validMoves[0];
        if (move) {
          g.prevX = g.x;
          g.prevY = g.y;
          g.x += move.dx;
          g.y += move.dy;
        }

        const pacmanCrossed = g.x === lastPacmanX && g.y === lastPacmanY && pacman.x === g.prevX && pacman.y === g.prevY;
        const sameTile = g.x === pacman.x && g.y === pacman.y;

        if ((sameTile || pacmanCrossed) && !g.eaten) {
          if (poweredUp) {
            g.eaten = true;
            g.x = Math.floor(cols / 2);
            g.y = Math.floor(rows / 2);
            score += 50;
          } else {
            gameOver = true;
            clearInterval(gameInterval);
            alert("Game Over! Final Score: " + score);
          }
        }
      });

      lastPacmanX = pacman.x;
      lastPacmanY = pacman.y;
    }

    function updateGame() {
      if (gameOver) return;

      if (poweredUp) {
        const elapsed = Date.now() - powerTimerStart;
        if (elapsed >= powerTimer) {
          poweredUp = false;
          powerTimer = 0;
        }
      }

      movePacman();
      moveGhosts();

      const remainingPellets = maze.flat().some(tile => tile === "." || tile === "o");
      if (!remainingPellets) {
        gameOver = true;
        clearInterval(gameInterval);
        alert("You Win! Final Score: " + score);
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMaze();
      drawEntity(pacman, "yellow");
      ghosts.forEach(g =>
        drawEntity(g, poweredUp && !g.eaten ? "blue" : g.color)
      );

      const timerLeft = poweredUp
        ? Math.max(0, ((powerTimer - (Date.now() - powerTimerStart)) / 1000).toFixed(1))
        : "";
      infoDisplay.textContent = `Score: ${score}` + (timerLeft ? ` | Power Time Left: ${timerLeft}s` : "");
    }

    const gameInterval = setInterval(updateGame, 150);
  </script>
</body>
</html>
